% disp4D_HAS.m
function [u_z, f_z, g_zz] = disp4D_HAS(pout, params)

% Uses the Green's function method of Bercoff et al. 2004 to calculate the 
% displacement field generated by the acoustic radiation force in an unbounded
% homogeneous visecoelastic medium. For simulations it is assumed
% that the forcing function is along z and displacement is calculated along z.
% 
% Relevant references:
%    1. Bercoff J, Tanter M, Muller M, Fink M. The role of viscosity in the impulse 
%        diffraction field of elastic waves induced by the acoustic radiation force.
%        IEEE Trans. Ultrason. Ferroelectr. Freq. Control 2004;51:1523?1536.
%
%     2. Hofstetter LW, Parker DL. Corrections to "The Role of Viscosity in the Impulse 
%        Diffraction Field of Elastic Waves Induced by the Acoustic Radiation Force" and 
%        "Supersonic Shear Imaging: A New Technique for Soft Tissue Elasticity Mapping." 
%        IEEE Trans. Ultrason. Ferroelectr. Freq. Control 2020.
%    
% All Green's function terms used contain singularities at r = 0. These simulations
% choose a gridding to include the singularity. However, this results in an 
% infinite value for the Green's function terms for the voxel centered on r = 0. To
% handle this the averave value of the Green's function term for the voxel centered
% at r = 0 converges. The singular value of the Green's function at r=0 is replaced 
% by the average value. This makes it possible to use fourier transorm methods
% to approximate the 4D convolution integral.
%    
%
% Inputs:
%   pout: [Pa] 3D pressure pattern from HAS simulation. Shape specifies the volume of
%              displacement model as well
%   params: 
%       cs:     [m/s] Shear Wave Speed of Medium Being Simulated
%       vs:     [Pa * s] Shear Viscosity of Medium           2/rho is a reasonable starting value
%       cp:     [m/s] Compression Waves Speed of Medium
%       rho:    [kg/m^3] Medium Density
%       absorptionCoefficient:      [Np/m] Acoustic Absorption 
%       delta_t:    [s] Time step interval for simulation
%       max_t:      [s] Simulate out to this maximum time
%       voxelSizes: [m] 3 element vector specifying spacing between voxels in x,y,z. 
%                       Doesn't need to be isotropic but preferred for improved handling
%                       of Greens function singularity.
%       n_time_steps_ARF_duration:  [#] Spefify number of time steps for ARF duration
%       singularity_method:     [#]  Specifying how singularities are handled
%               	 1; Averages in 3D over r=0 voxel for all terms. Replace singular value
%                       with average value (recommended approach)
%               	 2; Averages in 2D over r= 0 in z=0 plane for S-component and P-component
%                       terms. For Near field term (PS) assigns a value of zero at r = 0
%       terms:      [#] Specifying which Green's Function Terms to Use:
    %                       terms = 1; S-component
    %                       terms = 2; P-component
    %                       terms = 4; Near Field Term (PS)
    %                       terms = 3; S and P
    %                       terms = 5; S and PS  
    %                       terms = 6; P and PS 
    %                       terms = 7; S, P and PS
    %
    %
    %
    % Outputs:
    %   u_z:     [m] Simulated 4D (t, x, y, z) displacement.
    %   f_z:     [units] 4D (t, x, y, z) forcing function.
    %   g_zz:    4D (t, x, y, z) Greens function
    % 
    % 
    % Author:
    % Lorne Hofstetter
    % University of Utah
    % 2020
    % 
	% ------------------------------------------    
    
    % In Berfcoff vp is not bulk viscosity: vp = (eta_p + 2*eta_n_s)/rho
    % Assuming bulk viscosity is 0 for all simulations.
    eta_p = 0; 
    params.vp = eta_p/params.rho + 2 * params.vs;
    
    % Generating gridding
    [t x y z] = gridding(size(pout), params.voxelSizes, params.delta_t, params.max_t);

    % Checking available machine memory and issue awarning if memory may be insufficient.
    isEnoughMemory(t);
    
    % Generate forcing function
    f_z = generate_forcing_function(pout, t, params);
    
    % Generate Green's Function Terms
    gS_zz = generate_kernel_bercoff(t, x, y, z, params, 1);
    gP_zz = generate_kernel_bercoff(t, x, y, z, params,2);
    gPS_zz = generate_kernel_bercoff(t, x, y, z, params, 4);

    % Now generating g_zz dependening on desired simulation result
    if params.terms == 1
        % S-component
        g_zz = gS_zz;
    elseif params.terms == 2
        % just P-component
        g_zz = gP_zz;
    elseif params.terms == 3
        % P and S components
        g_zz = gS_zz + gP_zz;
    elseif params.terms == 4
        %just PS component
        g_zz = gPS_zz;
    elseif params.terms == 5
        % S and PS components
        g_zz = gS_zz + gPS_zz;
    elseif params.terms == 6
        % P and PS components
        g_zz = gP_zz + gPS_zz;
    elseif params.terms == 7
        % S, P and PS components
        g_zz = gS_zz + gP_zz + gPS_zz;
    else
        error('Invalid params.terms value')
    end
   
   % Clearing large memory items that are no longer used
   clear x y z t gS_zz gP_zz gPS_zz;

   % ---------- Computing the displacement along z using 4D convolution ------------------
   u_z = conv4D_bercoff(f_z, g_zz, params.voxelSizes, params.delta_t); 

end

function [t, x, y, z] = gridding(spatialDimensions, voxelSizes, delta_t, max_t)
    % Generates the simulation gridding
    % 
    % If the spatial dimenion along a given dimension has an even number of 
    % points (N), the origin is chosed to be at: index = N/2 + 1. 
    % For example, if N = 100 the origin in that dimension would be at index = 51.

    % If the spatial dimenion along a given dimension has an odd number of 
    % points (N). Then the origin along that dimension is defined to be at:
    % index = (N-1)/2 + 1.
    % For example, if N = 101 the origin in that dimension would be at index = 51.
    % ------------------------------------------
    
    res = {};
    % Stepping through each spatial dimension and defining vector of 1D values along dimension
    for j = 1:length(spatialDimensions)
        if mod(spatialDimensions(j),2) %Odd Case
            maxVal(j) = (spatialDimensions(j)-1)/2 * voxelSizes(j);
            res{j} = -maxVal(j):voxelSizes(j):maxVal(j);   
        else % Even Case
            maxVal(j) = spatialDimensions(j)/2 * voxelSizes(j);
            res{j} = -maxVal(j):voxelSizes(j):(maxVal(j)-voxelSizes(j));
        end
    end
    
    [t, x, y, z] = ndgrid(0:delta_t:max_t, res{1}, res{2}, res{3});
    
end

function index = get_spatial_origin(array)
    % Purpose is to return the indices (3 component vector) of the origin
    % where r = 0
    dims = size(array);
    if length(dims) == 4
        dims = dims(2:4); %Discarding the time dimension
    elseif length(dims) ~= 3
        error('unsupported array size in get_spatial_origin');
    end
    
    for j=1:length(dims)
        if mod(dims(j),2) % Odd Case
            index(j) = (dims(j)-1)/2 + 1;
        else %Even Case
            index(j) = dims(j)/2 + 1;
        end
    end
end


function f_z = generate_forcing_function(pout, t, params)

    % Convert complex pressure to intensity
    Intensity = (pout .* conj(pout)) / (params.rho .* params.cp);
    
    % Force densiy 
    force_density(1,:,:,:) = single(2 * Intensity * params.absorptionCoefficient / params.cp);
    
    % Defining forcing function to be the specied time duration.
    f_z = zeros(size(t), 'single');
    f_z(1:params.n_time_steps_ARF_duration,:,:,:) = repmat(force_density, [params.n_time_steps_ARF_duration, 1, 1, 1]);

end


function g = generate_kernel_bercoff(t, x, y, z, params, whichTerm)
% Function generates Bercoff's Greens Function.
%
% Inputs: 
%    t,x,y,z are the 4D gridded coordinate positions
%    params contains a number of important simulations parameters
%    whichTerm = 1 for S term, 2 for P term, 4 for PS term
%
% 1.) All terms are calculated using double variable types. Then they are 
% converted to single to help conserve memory when the 4D convolution is 
% performed. 
%
% r= 0 contains a singularity for all terms. How singularity is handled is 
% specified by params.singularity_method
%
% ------------------------------------------------------------- 

    switch whichTerm
        case 1 % Far Field S-Wave
            g = gSzz(t, x, y, z, params);
            
            % Fix singularity at r = 0
            if (params.singularity_method == 1)
                g_ave = singular_3D(params, 1);
            elseif (params.singularity_method == 2)
                g_ave = singular_2D(params, 1);
            end
            
            % replace singular value
            idx = get_spatial_origin(g);
            g(:,idx(1), idx(2), idx(3)) = g_ave;
            

        case 2 % Far Field P-Wave
            g = gPzz(t, x, y, z, params);
            
            % Fix singularity at r = 0
            if (params.singularity_method == 1)
                g_ave = singular_3D(params, 2);
            elseif (params.singularity_method == 2)
                g_ave = singular_2D(params, 2);
            end
            
            % replace singular value
            idx = get_spatial_origin(g);
            g(:,idx(1), idx(2), idx(3)) = g_ave;
            
            
        case 4 % Near field term PS
            g = gPSzz(t, x, y, z, params);

            % Fix singularity at r = 0
            if (params.singularity_method == 1)
                g_ave = singular_3D(params, 4);
            elseif (params.singularity_method == 2)
                g_ave = singular_2D(params, 4);
            end
            
            % replace singular value
            idx = get_spatial_origin(g);
            g(:,idx(1), idx(2), idx(3)) = g_ave;
            
            % Comment on singularity. For gPS_zz term it can be shown that the 
            % integral over a spherical volume centered on the singularity is 0.
            % This also holds for an isotropic voxel but doesn't necessarily hold 
            % for a rectangular voxel. This why we still assign this value numerically
            % for Method 1. For Method 2, the integral over near field term in 2D plane
            % goes to infinity. In this case we are still assigning a value of 0 to that 
            % voxel.
            
        otherwise
            error('Incorrect parameter for whichTerm')
    end

    % Greens function is always zero for t<=0 This can be shown by taking limit as t -> 0
    g(t<=0) = 0;
    
    % Convert variable type to save memory
    g = single(g);
 
end

function g = gSzz(t, x, y, z, params)
    % Function to compute the shear green's function far field term
    
    cs = params.cs;
    vs = params.vs;
    cp = params.cp;
    vp = params.vp;
    rho = params.rho;
    
    r = sqrt(x.^2 + y.^2 + z.^2);
    
    g = 1/(4*pi*rho*cs) * 1./sqrt(2*pi*vs*t) .* ...
        (1 - z.^2./r.^2)./r .* exp(-((cs*t-r).^2)./(2*vs*t));
    
end

function g = gPzz(t, x, y, z, params)
    % Function to compute the bulk green's function far field term
    
    cs = params.cs;
    vs = params.vs;
    cp = params.cp;
    vp = params.vp;
    rho = params.rho;
    
    r = sqrt(x.^2 + y.^2 + z.^2);
    
    g = 1/(4*pi*rho*cp) * 1./sqrt(2*pi*vp*t) .* ...
        z.^2./(r.^3) .* exp(-((cp*t-r).^2)./(2*vp*t));
    
end

function g = gPSzz(t, x, y, z, params)
    % Function to compute the green's function near field term
    
    cs = params.cs;
    vs = params.vs;
    cp = params.cp;
    vp = params.vp;
    rho = params.rho;
    
    r = sqrt(x.^2 + y.^2 + z.^2);
    
    Ip1 = sqrt(vp*t/(2*pi*cp)) .* (exp(-t.^2*cp^2./(2*vp*t)) - exp(-((cp*t-r).^2)./(2*vp*t)));
    Ip2 = (t/2) .* ( erf(cp.*t./sqrt(2*vp*t)) - erf((cp*t-r)./sqrt(2*vp*t)));
    Ip = Ip1 + Ip2;
    
    Is1 = sqrt(vs*t/(2*pi*cs)) .* (exp(-t.^2*cs^2./(2*vs*t)) - exp(-((cs*t-r).^2)./(2*vs*t)));
    Is2 = (t/2) .* ( erf(cs.*t./sqrt(2*vs*t)) - erf((cs*t-r)./sqrt(2*vs*t)));
    Is = Is1 + Is2;

    g = 1/(4*pi*rho) * (3*z.^2./r.^2 - 1)./(r.^3) .* (Is - Ip);
end
    

function g_ave = singular_3D(params, whichTerm)
    % It can be shown analytically that integration of gS_zz, gP_zz and gPS_zz
    % over a sphere centered on r=0 converges. This is a prerequisite for handling
    % the r=0 singularities in each of these terms.
    
    % In this function, the average value for the r=0 voxel is computed numerically 
    % by subdividing voxel into a 64x64x64 gridding that avoids the r = 0 origin.
    % The Green's function value at each subgrid position is calculated. All points are then 
    % averaged to generate an value to replace the singular green's function with.
    
    cs = params.cs;
    vs = params.vs;
    cp = params.cp;
    vp = params.vp;
    rho = params.rho;
    voxelSizes = params.voxelSizes;
    t_step = params.delta_t;
    t_max = params.max_t;
    
    [t, x, y, z] = voxel_subdivide(voxelSizes, t_step, t_max);
    r = sqrt(x.^2 + y.^2 + z.^2);
    
    switch whichTerm
       case 1 % Far Field S-Wave
            g = gSzz(t, x, y, z, params);
               
       case 2 % Far Field P-Wave
            g = gPzz(t, x, y, z, params);
            
       case 4 % Near field term PS
            g = gPSzz(t, x, y, z, params);
            
        otherwise
            error('Incorrect parameter for whichTerm')
    end
   
   % Computing average over spatial dimensions
   [x1 x2 x3 x4] = size(g);
   g = reshape(g, [x1, x2*x3*x4]);
   g_ave = mean(g,2);
   
   % Note g_ave(t=0) = 0;
   g_ave(1) = 0;
     
end

function g_ave = singular_2D(params, whichTerm)
    % It can be shown analytically that integration of gS_zz and gP_zz over a circle 
    % centered on r=0 in the z=0 plane converges. However the same integral over gPS_zz
    %does not converge.
    
    % In this function, for gS_zz and gP_zz, the average value for the r=0 voxel is computed numerically 
    % by subdividing voxel into a 64x64x1 gridding where z = 0. This gridding avoids the origin.
    % All points are then averaged to generate an value to replace the singular green's function with.
    
    % To handle the gPS_zz term we assign a value of 0 at the singularity. This is 
    % somewhat supported by the fact that an infinetesimal sphere about the r=0
    % singularity integrates to zero. (This is not very rigorous but 
    % is an interesting approach to try.)
    
    cs = params.cs;
    vs = params.vs;
    cp = params.cp;
    vp = params.vp;
    rho = params.rho;
    voxelSizes = params.voxelSizes;
    t_step = params.delta_t;
    t_max = params.max_t;
    
    [t, x, y, z] = voxel_subdivide_2D(voxelSizes, t_step, t_max);
    r = sqrt(x.^2 + y.^2 + z.^2);
    
    switch whichTerm
       case 1 % Far Field S-Wave
            g = gSzz(t, x, y, z, params);
               
       case 2 % Far Field P-Wave
            g = gPzz(t, x, y, z, params);
            
       case 4 % Near field term PS
            % Nothing needs to be computed as value 0 is assigned below
            
        otherwise
            error('Incorrect parameter for whichTerm')
    end
   
    if (whichTerm == 4) % Assign a value of zero at origin for near field term
        g_ave = zeros(size(t,1),1,1,1); 
    else
        % For all other scenarios computing the average

        [x1 x2 x3] = size(g);
        g = reshape(g, [x1, x2*x3]);
        g_ave = mean(g,2);
   
        % Note g_ave(t=0) = 0;
        g_ave(1) = 0;
    end 
end


function [t, x, y, z] = voxel_subdivide(voxelSizes, t_step, t_max)
    % Purpose of function is to generate gridding about origin
    arraySize = 64; %Setting default averaging volume to be 64x64x64 
    res = voxelSizes/arraySize;
    iso_max = voxelSizes/2 - res/2;
    [t, x, y, z] = ndgrid(0:t_step:t_max, -iso_max(1):res(1):iso_max(1), -iso_max(2):res(2):iso_max(2), -iso_max(3):res(3):iso_max(3));
    
end

function [t, x, y, z] = voxel_subdivide_2D(voxelSizes, t_step, t_max)
    % Purpose of function is to generate gridding about origin for 2D average
    arraySize = 64; %Setting default averaging volume to be 64x64 
    res = voxelSizes/arraySize;
    iso_max = voxelSizes/2 - res/2;
    [t, x, y, z] = ndgrid(0:t_step:t_max, -iso_max(1):res(1):iso_max(1), -iso_max(2):res(2):iso_max(2), 0);
    
end


function [fg] = conv4D_bercoff(f,g, voxelSizes, delta_t)
    % Perform 4D convolution integral convolution of f & g. 
    
    % f & g are 4 dimensional vector with dimensions [t, x, y, z]
    % current version requires that f & g are the same size
    % Convolution is performed using the steps outlined in:
        % Digital Image Processing, Gonzalez & Woods, 3rd Ed.
    % Also assuming input signal is real.
    % For scaling, convolution must be multiplied by, dt, dx, dy, dz

    
    % ----------------- Input Error Handling ----------------------
    if (ndims(f) > 4 || ndims(f) < 2)
        error('Input matrix 1 must be of dimension 2, 3, or 4')
    elseif (ndims(g) > 4 || ndims(g) < 2)
        error('Input matrix 1 must be of dimension 2, 3, or 4')
    elseif (ndims(g) ~= ndims(f))
        error('Two input matrices must be the same dimension')
    end
    %--------------------------------------------------------------
                
    
    P = [];                 %vector for holding size of padded matrices
    idx = {1, 1, 1, 1};     %cell list for holding the indices up to 4 dim
    idx_new = {1, 1, 1, 1};
    for j=1:ndims(f)
        P(j) = 2*size(f,j);
        idx{j} = 1:size(f,j);
        idx_new{j} = 1:2*size(f,j);
    end
    
    % These are the padded arrays
    f_new = zeros(P, 'single');
    f_new(idx{1}, idx{2}, idx{3}, idx{4}) = f;
    clear f;
    
    g_new = zeros(P, 'single');
    g_new(idx{1}, idx{2}, idx{3}, idx{4}) = g;
    clear g;

    % Calculating FFT. (Confusing but for memory purposes using same variable name
    disp('Starting 4D-FFT...');
    tic
    for j = 1:ndims(f_new)
        f_new = fft(f_new, [], j);
        g_new = fft(g_new, [], j);
    end
    disp('End FFT');
    toc

    % If RAM memory limit exceeded, this multiplcation is extremely slow.
    % (Again confusing but overwriting f_new as multiplied product to conserve memory.)
    disp('Start element wise multiplication. (Fast if sufficient memory...');
    tic
    f_new = f_new .* g_new;
    disp('End multiplication');
    toc
    
    clear g_new;
    
    disp('Starting 4D-iFFT...') 
    tic
    for j=1:ndims(f_new)
        f_new = ifft(f_new, [], j);
    end
    disp('End iFFT')
    toc
        
    % Scaling handles voxels that aren't isotropic
    scaling = voxelSizes(1) * voxelSizes(2) * voxelSizes(3) * delta_t;
    
    % Crop result and apply scaling term.
    fg = real(f_new(idx{1}, (floor(idx{2}(end)/2)+1):(floor(idx{2}(end)*3/2)), ...
        (floor(idx{3}(end)/2)+1):(floor(idx{3}(end)*3/2)),... 
        (floor(idx{4}(end)/2)+1):(floor(idx{4}(end)*3/2)))) * scaling;
end

function [] = isEnoughMemory(t)
[x1 x2 x3 x4] = size(t);
memArrayZeroPadSingleComplex = 4 * 2 * x1 * x2 * x3 * x4 *2^4 /1e9; % In GB

% Getting system memory
[status, cmdout]=system('sysctl hw.memsize | awk ''{print $2}''');
systemMemory = str2num(cmdout)/1e9;

disp(['Memory Needed for One Array in Convolution = ' num2str(memArrayZeroPadSingleComplex) ' Gb']);
disp(['System Memory =' num2str(systemMemory) ' Gb']);
if (memArrayZeroPadSingleComplex < systemMemory * 0.375)
    disp('Sufficient memory for computation')
else
    warning('Memory may be insufficient for computation. Consider reducing size of simulation grid');
end
end


    




